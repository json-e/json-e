<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>JSON-e</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0"></script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="docs/jsone.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- JSON-e: add logo -->
            <div class="json-e-logo">
                <img src="logo-white.png" width="128" height="128" alt="JSON-e Logo" />
            </div>
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="using.html"><strong aria-hidden="true">2.</strong> Using JSON-e</a></li><li class="chapter-item expanded "><a href="language.html"><strong aria-hidden="true">3.</strong> Language Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="simple.html"><strong aria-hidden="true">3.1.</strong> Simple Usage</a></li><li class="chapter-item expanded "><a href="operators.html"><strong aria-hidden="true">3.2.</strong> Operators</a></li><li class="chapter-item expanded "><a href="expressions.html"><strong aria-hidden="true">3.3.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="built-ins.html"><strong aria-hidden="true">3.4.</strong> Built-Ins</a></li></ol></li><li class="chapter-item expanded "><a href="playground.html"><strong aria-hidden="true">4.</strong> Playground</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">JSON-e</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/json-e/json-e" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="json-e"><a class="header" href="#json-e">JSON-e</a></h1>
<p>JSON-e is a data-structure parameterization system for embedding context in
JSON objects.</p>
<p>The central idea is to treat a data structure as a &quot;template&quot; and render it,
using another data structure as &quot;context&quot;, to produce an output data structure.</p>
<p>There are countless libraries to do this with strings, such as
<a href="https://mustache.github.io/">mustache</a>. What makes JSON-e unique is that it
operates on data structures, not on their textual representation. This allows
input to be written in a number of formats (JSON, YAML, etc.) or even generated
dynamically. It also means that the output cannot be &quot;invalid&quot;, even when
including large chunks of contextual data.</p>
<p>JSON-e is also designed to be safe for use on untrusted data. It never uses
<code>eval</code> or any other function that might result in arbitrary code execution. It
also disallows unbounded iteration, so any JSON-e rendering operation will
finish in finite time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-json-e"><a class="header" href="#using-json-e">Using JSON-e</a></h1>
<p>An application of JSON-e typically allows the user to specify the template, and
defines the context with which that template will be rendered as well as how
the output will be interpreted. For example, an application that allows
customized responses to chat messages might provide context <code>{&quot;message&quot;: .., &quot;sender&quot;: ..}</code> and expect an object of the form <code>{&quot;reply&quot;: ..}</code> as a result.</p>
<p>JSON-e is intended for cross-platform usage, and has native implementations in several languages.</p>
<h2 id="javascript"><a class="header" href="#javascript">JavaScript</a></h2>
<p>The JS module is installed into a Node project with</p>
<pre><code class="language-shell">npm install --save json-e
yarn add json-e
</code></pre>
<p>The module exposes following interface:</p>
<pre><code class="language-javascript">import jsone from 'json-e';

var template = {a: {$eval: &quot;foo.bar&quot;}};
var context = {foo: {bar: &quot;zoo&quot;}};
console.log(jsone(template, context));
// -&gt; { a: 'zoo' }
</code></pre>
<p>Note that the context can contain functions, and those functions can be called
from the template:</p>
<pre><code class="language-javascript">var template = {$eval: &quot;foo(1)&quot;};
var context = {&quot;foo&quot;: function(x) { return x + 2; }};
console.log(jsone(template, context));  // -&gt; 3
</code></pre>
<p><em>NOTE</em>: Context functions are called synchronously. Any complex asynchronous
operations should be handled before rendering the template.</p>
<p><em>NOTE</em>: If the template is untrusted, it can pass arbitrary data to functions
in the context, which must guard against such behavior.</p>
<h3 id="browser"><a class="header" href="#browser">Browser</a></h3>
<p>JSON-e has a single-file, browser-compatible implementation in <code>dist/index.js</code> in the NPM release.
This file can be used directly in a browser to add JSON-e functionality.</p>
<p>JSON-e can be used from a CDN with</p>
<pre><code class="language-html">&lt;script
  type=&quot;text/javascript&quot;
  src=&quot;https://cdn.jsdelivr.net/npm/json-e&quot;&gt;
&lt;/script&gt;
</code></pre>
<h2 id="typescript"><a class="header" href="#typescript">TypeScript</a></h2>
<p>The JS module is installed with either of</p>
<pre><code class="language-shell">npm install --save json-e
yarn add json-e
</code></pre>
<p>Note: Type definitions are included with this package, so there's no need of seperate
<code>@types/..</code> installation.</p>
<p>As 'json-e' is a CommonJS module, the package must be imported like this <a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require">(more..)</a> for type definitions to work properly:</p>
<pre><code class="language-typescript">const jsone = require('json-e');

var template = {a: {$eval: &quot;foo.bar&quot;}};
var context = {foo: {bar: &quot;zoo&quot;}};
console.log(jsone(template, context));
// -&gt; { a: 'zoo' }
</code></pre>
<h2 id="python"><a class="header" href="#python">Python</a></h2>
<p>The Python distribution is installed with</p>
<pre><code class="language-shell">pip install json-e
</code></pre>
<p>The distribution exposes a <code>render</code> function:</p>
<pre><code class="language-python">import jsone

template = {&quot;a&quot;: {&quot;$eval&quot;: &quot;foo.bar&quot;}}
context = {&quot;foo&quot;: {&quot;bar&quot;: &quot;zoo&quot;}}
print(jsone.render(template, context))  # -&gt; {&quot;a&quot;: &quot;zoo&quot;}
</code></pre>
<p>and also allows custom functions in the context:</p>
<pre><code class="language-python">template = {&quot;$eval&quot;: &quot;foo(1)&quot;}
context = {&quot;foo&quot;: lambda x: x + 2}
print(jsone.render(template, context))  # -&gt; 3
</code></pre>
<h2 id="go-golang"><a class="header" href="#go-golang">Go (golang)</a></h2>
<p>The <a href="https://pkg.go.dev/github.com/json-e/json-e/v4">golang package for json-e</a> exposes a <code>Render</code> function:</p>
<pre><code class="language-golang">import (
  &quot;fmt&quot;
  jsone &quot;github.com/json-e/json-e/v4&quot;
)

// Template must be given using types:
//   map[string]interface{}, []interface{}, float64, string, bool, nil
// The same types that json.Unmarshal() will create when targeting an interface{}
var template = map[string]interface{}{
  &quot;result&quot;: map[string]interface{}{
    &quot;$eval&quot;: &quot;f() + 5&quot;,
  },
}
// Context can be JSON types just like template, but may also contain functions
// these can JSON types as arguments, and return a value and optionally an error.
var context = map[string]interface{}{
  &quot;f&quot;: jsone.WrapFunction(func() float64 { return 37 }),
}

func main() {
  value, _ := jsone.Render(template, context)
  fmt.Printf(&quot;%#v\n&quot;, value)
}
</code></pre>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<p>The Rust crate exposes a <code>render</code> function which takes the template and context as <code>serde_json</code> <code>Value</code> objects, and returns an object of the same type.</p>
<pre><code class="language-rust ignore">use serde_json::json;

fn main() {
    println!(&quot;result: {:?}&quot;, json_e::render(
        json!({$eval: &quot;a + b&quot;}),
        json!({a: 10, b: 20})));
}
</code></pre>
<p>See <a href="https://docs.rs/json-e">docs.rs</a> for the full API docs.</p>
<h2 id="net"><a class="header" href="#net">.NET</a></h2>
<p>See <a href="https://json-everything.net/json-e">json-everything</a> for a .NET implementation of JSON-e.</p>
<h2 id="third-party-integrations"><a class="header" href="#third-party-integrations">Third-Party Integrations</a></h2>
<h3 id="rjsone"><a class="header" href="#rjsone">rjsone</a></h3>
<p>You can use the 3rd party package <a href="https://wryun.github.io/rjsone/">rjsone</a> to template
JSON-e from the command line, passing templates/contexts as files or arguments and using
stdout for the result.</p>
<h3 id="bazel"><a class="header" href="#bazel">Bazel</a></h3>
<p>You can use 3rd party <a href="https://github.com/atlassian/bazel-tools/tree/master/rjsone">Bazel rule</a> to invoke
rjsone (see above) from Bazel build files.</p>
<h3 id="terraform"><a class="header" href="#terraform">Terraform</a></h3>
<p>The <a href="https://github.com/taskcluster/terraform-provider-jsone">jsone Terraform provider</a> allows use of JSON-e for templating objects within Terraform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-reference"><a class="header" href="#language-reference">Language Reference</a></h1>
<p>The following sections describe the JSON-e language.</p>
<p>The examples here are given in YAML for ease of reading.  Of course, the
rendering operation takes place on the parsed data, so the input format is
irrelevant to its operation.</p>
<h2 id="rendering"><a class="header" href="#rendering">Rendering</a></h2>
<p>A JSON-e template is rendered with a context to produce a result. The template,
context, and result are all data structures containing strings, numbers,
true/false, null, objects, and arrays -- the type of data structure you get
from parsing JSON.</p>
<p>The context is an object, giving values for variables at the top level of the
template.</p>
<h2 id="variables-and-scope"><a class="header" href="#variables-and-scope">Variables and Scope</a></h2>
<p>Variables are defined in a set of nested scopes. When an
<a href="./expressions.html">expression</a> references a variable, evaluation looks for a
variable of that name in all scopes, from innermost to outermost, and uses the
first that it finds.</p>
<p>The outermost scope are the <a href="./built-ins.html">built-ins</a>. The context passed to
the render call is used as the next scope, an thus can override built-in
variables. Some operators, such as <code>$let</code>, allow the template to define
additional scopes during rendering.</p>
<p>Variables can contain functions defined by the caller. While these functions
can be used during rendering, it is an error for them to appear in the result.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-usage"><a class="header" href="#simple-usage">Simple Usage</a></h1>
<p>All JSON-e directives involve the <code>$</code> character, so a template without any directives is
rendered unchanged:</p>
<pre><code class="language-yaml json-e">template: {key: [1,2,{key2: 'val', key3: 1}, true], f: false}
context:  {}
result:   {key: [1,2,{key2: 'val', key3: 1}, true], f: false}
</code></pre>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>The simplest form of substitution occurs within strings, using <code>${..}</code>:</p>
<pre><code class="language-yaml json-e">template: {message: 'hello ${key}', 'k=${num}': true}
context:  {key: 'world', num: 1}
result:   {message: 'hello world', 'k=1': true}
</code></pre>
<p>The bit inside the <code>${..}</code> is an <a href="./expressions.html">expression</a>, and must evaluate to something
that interpolates obviously into a string (a string, number, or boolean).
If it is null, then the expression interpolates into an empty string.</p>
<p>Values interpolate as their JSON literal values:</p>
<pre><code class="language-yaml json-e">template: [&quot;number: ${num}&quot;, &quot;booleans: ${t} ${f}&quot;, &quot;null: ${nil}&quot;]
context: {num: 3, t: true, f: false, nil: null}
result: [&quot;number: 3&quot;, &quot;booleans: true false&quot;, &quot;null: &quot;]
</code></pre>
<p>Note that object keys can be interpolated, too:</p>
<pre><code class="language-yaml json-e">template: {&quot;tc_${name}&quot;: &quot;${value}&quot;}
context: {name: 'foo', value: 'bar'}
result: {&quot;tc_foo&quot;: &quot;bar&quot;}
</code></pre>
<p>The string <code>${</code> can be escaped as <code>$${</code>:</p>
<pre><code class="language-yaml json-e">template: {&quot;literal:$${name}&quot;: &quot;literal&quot;}
context: {name: 'foo'}
result: {&quot;literal:${name}&quot;: &quot;literal&quot;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>JSON-e defines a bunch of operators. Each is represented as an object with a
property beginning with <code>$</code>. This object can be buried deeply within the
template. Some operators take additional arguments as properties of the same
object.</p>
<h2 id="truthiness"><a class="header" href="#truthiness">Truthiness</a></h2>
<p>Many values can be evaluated in context where booleans are required,
not just booleans themselves. JSON-e defines the following values as false.
Anything else will be true.</p>
<pre><code class="language-yaml json-e">template: {$if: 'a || b || c || d || e || f', then: &quot;uh oh&quot;, else: &quot;falsy&quot; }
context: {a: null, b: [], c: {}, d: &quot;&quot;, e: 0, f: false}
result: &quot;falsy&quot;
</code></pre>
<h2 id="eval"><a class="header" href="#eval"><code>$eval</code></a></h2>
<p>The <code>$eval</code> operator evaluates the given expression and is replaced with the
result of that evaluation. Unlike with string interpolation, the result need
not be a string, but can be an arbitrary data structure.</p>
<pre><code class="language-yaml json-e">template: {config: {$eval: 'settings.staging'}}
context:
  settings:
    staging:
      transactionBackend: mock
    production:
      transactionBackend: customerdb
result:
  {config: {transactionBackend: 'mock'}}
</code></pre>
<p>The expression syntax is described in more detail below.</p>
<p>Note that <code>$eval</code>'s value must be a string. &quot;Metaprogramming&quot; by providing a
calculated value to eval is not allowed.  For example, <code>{$eval: {$eval: &quot;${var1} + ${var2}&quot;}}</code> is not valid JSON-e.</p>
<h2 id="json"><a class="header" href="#json"><code>$json</code></a></h2>
<p>The <code>$json</code> operator formats the given value as JSON with sorted keys. It does
not evaluate the value (use <code>$eval</code> for that). While this can be useful in some
cases, it is an unusual case to include a JSON string in a larger data
structure.</p>
<p>Parsing the result of this operator with any compliant JSON parser will give
the same results. However, the encoding may differ between implementations of
JSON-e. For example, numeric representations or string escapes may differ
between implementations.</p>
<pre><code class="language-yaml json-e">template: {$json: [a, b, {$eval: 'a+b'}, 4]}
context:  {a: 1, b: 2}
result:   '[&quot;a&quot;,&quot;b&quot;,3,4]'
</code></pre>
<h2 id="if---then---else"><a class="header" href="#if---then---else"><code>$if</code> - <code>then</code> - <code>else</code></a></h2>
<p>The <code>$if</code> operator supports conditionals. It evaluates the given value, and
replaces itself with the <code>then</code> or <code>else</code> properties. If either property is
omitted, then the expression is omitted from the parent object.</p>
<pre><code class="language-yaml json-e">template: {key: {$if: 'cond', then: 1}, k2: 3}
context:  {cond: true}
result:   {key: 1, k2: 3}
</code></pre>
<pre><code class="language-yaml json-e">template: {$if: 'x &gt; 5', then: 1, else: -1}
context:  {x: 10}
result:   1
</code></pre>
<pre><code class="language-yaml json-e">template: [1, {$if: 'cond', else: 2}, 3]
context: {cond: false}
result: [1,2,3]
</code></pre>
<pre><code class="language-yaml json-e">template: {key: {$if: 'cond', then: 2}, other: 3}
context: {cond: false}
result: {other: 3}
</code></pre>
<h2 id="flatten"><a class="header" href="#flatten"><code>$flatten</code></a></h2>
<p>The <code>$flatten</code> operator flattens an array of arrays into one array.</p>
<pre><code class="language-yaml json-e">template: {$flatten: [[1, 2], [3, 4], [5]]}
context:  {}
result:   [1, 2, 3, 4, 5]
</code></pre>
<h2 id="flattendeep"><a class="header" href="#flattendeep"><code>$flattenDeep</code></a></h2>
<p>The <code>$flattenDeep</code> operator deeply flattens an array of arrays into one array.</p>
<pre><code class="language-yaml json-e">template: {$flattenDeep: [[1, [2, [3]]]]}
context:  {}
result:   [1, 2, 3]
</code></pre>
<h2 id="fromnow"><a class="header" href="#fromnow"><code>$fromNow</code></a></h2>
<p>The <code>$fromNow</code> operator is a shorthand for the built-in function <code>fromNow</code>. It
creates a JSON (ISO 8601) datestamp for a time relative to the current time
(see the <code>now</code> builtin, below) or, if <code>from</code> is given, relative to that time.</p>
<p>The offset is specified by a sequence of number/unit pairs in a string.
Whitespace is ignored, but the units must be given in ordre from largest to
smallest. To produce a time in the past, prefix the string with <code>-</code>. A <code>+</code>
prefix is allowed as a redundant way to specify a time in the future.</p>
<pre><code class="language-yaml json-e">template: {$fromNow: '2 days 1 hour'}
context:  {}
result:   '2017-01-21T17:27:20.974Z'
</code></pre>
<pre><code class="language-yaml json-e">template: {$fromNow: '1 hour', from: '2017-01-19T16:27:20.974Z'}
context:  {}
result:   '2017-01-19T17:27:20.974Z'
</code></pre>
<p>The available units, including useful shorthands, are:</p>
<pre><code class="language-none">years,    year,   yr,   y
months,   month,  mo
weeks,    week,   wk,   w
days,     day,          d
hours,    hour,   hr,   h
minutes,  minute, min,  m
seconds,  second, sec,  s
</code></pre>
<h2 id="let"><a class="header" href="#let"><code>$let</code></a></h2>
<p>The <code>$let</code> operator evaluates an expression using a context amended with the
given values. It is analogous to the Haskell <code>where</code> clause.</p>
<pre><code class="language-yaml json-e">template: {$let: {ts: 100, foo: 200},
           in: [{$eval: &quot;ts+foo&quot;}, {$eval: &quot;ts-foo&quot;}, {$eval: &quot;ts*foo&quot;}]}
context: {}
result: [300, -100, 20000]
</code></pre>
<p>The <code>$let</code> operator here added the <code>ts</code> and <code>foo</code> variables to the scope of
the context and accordingly evaluated the <code>in</code> clause using those variables
to return the correct result.</p>
<p>An expression like <code>{$let: {$eval: &quot;extraVariables&quot;}, in : ..}</code> is supported. As long as
the value of <code>$let</code> evaluates to an object with valid key(s), the <em>values</em> of which are
evaluated.</p>
<pre><code class="language-yaml json-e">template: {$let: {$if: something == 3, then: {a: 10, b: 10}, else: {a: 20, b: 10}},
          in: {$eval: 'a + b'}}
context:  {'something': 3}
result:   20
</code></pre>
<pre><code class="language-yaml json-e">template: {$let: {&quot;b&quot;: {$eval: &quot;a + 10&quot;}},
          in: {$eval: &quot;a + b&quot;}}
context:  {a: 5}
result:   20
</code></pre>
<pre><code class="language-yaml json-e">template: {$let: {&quot;first_${name}&quot;: 1, &quot;second_${name}&quot;: 2},
          in: {$eval: &quot;first_prize + second_prize&quot;}}
context:  {name: &quot;prize&quot;}
result:   3
</code></pre>
<h2 id="map"><a class="header" href="#map"><code>$map</code></a></h2>
<p>The <code>$map</code> operator evaluates an expression for each value of the given array or object,
constructing the result as an array or object of the evaluated values.</p>
<h3 id="over-arrays"><a class="header" href="#over-arrays">Over Arrays</a></h3>
<p>When given an array, <code>$map</code> always returns an array.</p>
<pre><code class="language-yaml json-e">template:
  $map: [2, 4, 6]
  each(x): {$eval: 'x + a'}
context:  {a: 1}
result:   [3, 5, 7]
</code></pre>
<p>The <code>each</code> function can define two variables, in which case the second is the 0-based index of the element.</p>
<pre><code class="language-yaml json-e">template:
  $map: [2, 4, 6]
  each(x,i): {$eval: 'x + a + i'}
context:  {a: 1}
result:   [3, 6, 9]
</code></pre>
<h3 id="over-objects"><a class="header" href="#over-objects">Over Objects</a></h3>
<p>When given an object, <code>$map</code> always returns an object.
The <code>each</code> function defines variables for the value and key, in that order.
It must evaluate to an object for each item.
These objects are then merged, with later keys overwriting earlier keys, to produce the final object.</p>
<pre><code class="language-yaml json-e">template:
  $map: {a: 1, b: 2, c: 3}
  each(v,k): {'${k}x': {$eval: 'v + 1'}}
context:  {}
result: {ax: 2, bx: 3, cx: 4}
</code></pre>
<p>If <code>each</code> is defined to take only one variable, then that variable is an object with properties <code>key</code> and <code>val</code>.</p>
<pre><code class="language-yaml json-e">template:
  $map: {a: 1, b: 2, c: 3}
  each(y): {'${y.key}x': {$eval: 'y.val + 1'}}
context:  {}
result: {ax: 2, bx: 3, cx: 4}
</code></pre>
<h2 id="reduce"><a class="header" href="#reduce"><code>$reduce</code></a></h2>
<p>The <code>$reduce</code> operator evaluates an expression with each value of the given array and
the result of the prior expression, reducing the array into a single JSON value.</p>
<p>This operation is sometimes called <code>fold</code>, <code>accumulate</code>, <code>aggregate</code>, or <code>inject</code>.</p>
<p>An initial result is passed as the accumulator for the first evaluation of the expression.</p>
<p>The <code>each</code> function defines the accumulated, or prior result, and the current value.  The result of
this function will be passed as the accumulated to the next call of <code>each</code>.</p>
<pre><code class="language-yaml json-e">template:
  $reduce: [{name: Apple, price: 1}, {name: Orange, price: 0.75}, {name: Pear, price: 1.1}]
  initial: 0
  each(acc, v): {$eval: 'acc + v.price'}
context:  {}
result:   2.85
</code></pre>
<p>The <code>each</code> function can define three variables, in which case the third is the 0-based index of the element.</p>
<pre><code class="language-yaml json-e">template:
  $reduce: [2, 5, 8]
  initial: 0
  each(acc, v, i): {$eval: 'acc + v * 10 ** i'}
context:  {}
result:   852
</code></pre>
<h2 id="find"><a class="header" href="#find"><code>$find</code></a></h2>
<p>The <code>$find</code> operator evaluates an expression for each value of the given array.
returning the first value for which the expression evaluates to <code>true</code>.</p>
<p>If there are no matches the result is either <code>null</code> or if used within an object or array, omitted
from the parent object.</p>
<pre><code class="language-yaml json-e">template:
  $find: [2, 4, 6]
  each(x): x == 4
context: {}
result: 4
</code></pre>
<p>Using context variables:</p>
<pre><code class="language-yaml json-e">template:
  $find: [2, 4, 6]
  each(x): a == x
context: {a: 4}
result: 4
</code></pre>
<p>Omitting from parent:</p>
<pre><code class="language-yaml json-e">template:
  a: 1
  b:
    $find: [2, 4, 6]
    each(x): b == x
context:
  b: 3
result:
  a: 1
</code></pre>
<p>The <code>each</code> function can define two variables, in which case the second is the 0-based index of the element.</p>
<pre><code class="language-yaml json-e">template:
  $find: [2, 4, 6]
  each(x,i): i == 2
context: {}
result: 6
</code></pre>
<h2 id="match"><a class="header" href="#match"><code>$match</code></a></h2>
<p>The <code>$match</code> operator is not dissimilar to pattern matching operators.  It gets
an object, in which every key is a string expression evaluating to <code>true</code>
or <code>false</code> based on the context. Keys are evaluated in lexical order, and the
result is an array containing values corresponding to keys that evaluated to
<code>true</code>.  If there are no matches, the result is an empty array.</p>
<pre><code class="language-yaml json-e">template:
  $match: 
    &quot;c &gt; 10&quot;: &quot;cherry&quot;
    &quot;b &gt; 10&quot;: &quot;banana&quot;
    &quot;a &gt; 10&quot;: &quot;apple&quot;
context: {a: 200, b: 3, c: 19}
result: [&quot;apple&quot;, &quot;cherry&quot;]
</code></pre>
<pre><code class="language-yaml json-e">template: {$match: {&quot;x &lt; 10&quot;: &quot;tens&quot;}}
context: {x: 10}
result: []
</code></pre>
<h2 id="switch"><a class="header" href="#switch"><code>$switch</code></a></h2>
<p>The <code>$switch</code> operator behaves like a combination of the <code>$if</code> and
<code>$match</code> operator for more complex boolean logic. It gets an object,
in which every key is a string expression(s), where at most <em>one</em> must
evaluate to <code>true</code> and the remaining to <code>false</code> based on the context.
The result will be the value corresponding to the key that were
evaluated to <code>true</code> or optionally the fallback <code>$default</code> value.</p>
<p>If there are no matches, and no <code>$default</code> fallback is provided, the
result is either null or if used within an object or array, omitted
from the parent object.</p>
<pre><code class="language-yaml json-e">template: {$switch: {&quot;x == 10&quot;: &quot;ten&quot;, &quot;x == 20&quot;: &quot;twenty&quot;}}
context: {x: 10}
result: &quot;ten&quot;
</code></pre>
<pre><code class="language-yaml json-e">template: {$switch: {&quot;x &lt; 10&quot;: 1}}
context: {x: 10}
result: null
</code></pre>
<pre><code class="language-yaml json-e">template: {a: 1, b: {$switch: {&quot;x == 10 || x == 20&quot;: 2, &quot;x &gt; 20&quot;: 3}}}
context: {x: 10}
result: {a: 1, b: 2}
</code></pre>
<pre><code class="language-yaml json-e">template: {a: 1, b: {$switch: {&quot;x == 1&quot;: 2, &quot;x == 3&quot;: 3}}}
context: {x: 2}
result: {a: 1}
</code></pre>
<pre><code class="language-yaml json-e">template: [1, {$switch: {&quot;x == 2&quot;: 2, &quot;x == 10&quot;: 3}}]
context: {x: 2}
result: [1, 2]
</code></pre>
<pre><code class="language-yaml json-e">template: [0, {$switch: {'cond &gt; 3': 2, 'cond == 5': 3}}]
context:  {cond: 3}
result:   [0]
</code></pre>
<pre><code class="language-yaml json-e">template: [0, {$switch: {'cond &gt; 3': 2, 'cond == 5': 3, $default: 4}}]
context:  {cond: 1}
result:   [4]
</code></pre>
<h2 id="merge"><a class="header" href="#merge"><code>$merge</code></a></h2>
<p>The <code>$merge</code> operator merges an array of objects, returning a single object
that combines all of the objects in the array, where the right-side objects
overwrite the values of the left-side ones.</p>
<pre><code class="language-yaml json-e">template: {$merge: [{a: 1, b: 1}, {b: 2, c: 3}, {d: 4}]}
context:  {}
result:   {a: 1, b: 2, c: 3, d: 4}
</code></pre>
<h2 id="mergedeep"><a class="header" href="#mergedeep"><code>$mergeDeep</code></a></h2>
<p>The <code>$mergeDeep</code> operator is like <code>$merge</code>, but it recurses into objects to
combine their contents property by property.  Arrays are concatenated.</p>
<pre><code class="language-yaml json-e">template:
  $mergeDeep:
    - task:
        payload:
          command: [a, b]
    - task:
        extra:
          foo: bar
    - task:
        payload:
          command: [c]
context:  {}
result:
  task:
    extra:
      foo: bar
    payload:
      command: [a, b, c]
</code></pre>
<h2 id="sort"><a class="header" href="#sort"><code>$sort</code></a></h2>
<p>The <code>$sort</code> operator sorts the given array. It takes a <code>by(var)</code> property which
should evaluate to a comparable value for each element. The <code>by(var)</code> property
defaults to the identity function.</p>
<p>The values sorted must all be of the same type, and either a number or a string.</p>
<pre><code class="language-yaml json-e">template:
  $sort: [{a: 2}, {a: 1, b: []}, {a: 3}]
  by(x): 'x.a'
context:  {}
result:   [{a: 1, b: []}, {a: 2}, {a: 3}]
</code></pre>
<p>The sort is stable:</p>
<pre><code class="language-yaml json-e">template:
  $sort: [&quot;aa&quot;, &quot;dd&quot;, &quot;ac&quot;, &quot;ba&quot;, &quot;ab&quot;]
  by(x): 'x[0]'
context:  {}
# stable: all &quot;a&quot; strings remain in the same order relative to one another.
result:   [&quot;aa&quot;, &quot;ac&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;dd&quot;]
</code></pre>
<h2 id="reverse"><a class="header" href="#reverse"><code>$reverse</code></a></h2>
<p>The <code>$reverse</code> operator simply reverses the given array.</p>
<pre><code class="language-yaml json-e">template: {$reverse: [3, 4, 1, 2]}
context:  {}
result:   [2, 1, 4, 3]
</code></pre>
<h2 id="escaping-operators"><a class="header" href="#escaping-operators">Escaping operators</a></h2>
<p>All property names starting with <code>$</code> are reserved for JSON-e.
You can use <code>$$</code> to escape such properties:</p>
<pre><code class="language-yaml json-e">template: {$$reverse: [3, 2, {$$eval: '2 - 1'}, 0]}
context:  {}
result:   {$reverse: [3, 2, {$eval: '2 - 1'}, 0]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>Expression are given in a simple Python- or JavaScript-like expression
language. Its data types are limited to JSON types plus function objects.</p>
<h2 id="literals"><a class="header" href="#literals">Literals</a></h2>
<p>Literals are similar to those for JSON Numeric literals, but only accept integer and
decimal notation.</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: &quot;1.3&quot;}
context: {}
result:
  - 1.3
</code></pre>
<p>Strings do not support any kind of escaping, but can be enclosed in either <code>&quot;</code>
or in <code>'</code>. To avoid confusion when writing JSON-e expressions in YAML or JSON
documents, remember that JSON-e operates on the data structure that results
<em>after</em> YAML or JSON parsing is complete.</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: &quot;'abc'&quot;}
  - {$eval: '&quot;abc&quot;'}
context: {}
result:
  - &quot;abc&quot;
  - &quot;abc&quot;
</code></pre>
<p>Array and object literals also look much like JSON, with bare identifiers
allowed as keys like in Javascript:</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: '[1, 2, &quot;three&quot;]'}
  - {$eval: '{foo: 1, &quot;bar&quot;: 2}'}
context: {}
result:
  - [1, 2, &quot;three&quot;]
  - {&quot;foo&quot;: 1, &quot;bar&quot;: 2}
</code></pre>
<h2 id="context-references"><a class="header" href="#context-references">Context References</a></h2>
<p>Bare identifiers refer to items from the context or to built-ins (described below).</p>
<pre><code class="language-yaml json-e">template: {$eval: '[x, z, x+z]'}
context: {x: 'quick', z: 'sort'}
result: ['quick', 'sort', 'quicksort']
</code></pre>
<p>Valid identifiers for context references follow the requirements of many
programming languages: identifiers may only contain letters, underscores, and
numbers, but may not start with a number. This does imply that the context
object may only have keys that meet these requirements.</p>
<h2 id="arithmetic-operations"><a class="header" href="#arithmetic-operations">Arithmetic Operations</a></h2>
<p>The usual arithmetic operators are all defined, with typical associativity and
precedence:</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: 'x + z'}
  - {$eval: 's + t'}
  - {$eval: 'z - x'}
  - {$eval: 'x * z'}
  - {$eval: 'z / x'}
  - {$eval: 'z ** 2'}
  - {$eval: '(z / x) ** 2'}
context: {x: 10, z: 20, s: &quot;face&quot;, t: &quot;plant&quot;}
result:
  - 30
  - &quot;faceplant&quot;
  - 10
  - 200
  - 2
  - 400
  - 4
</code></pre>
<p>Note that strings can be concatenated with <code>+</code>, but none of the other operators
apply.</p>
<h2 id="comparison-operations"><a class="header" href="#comparison-operations">Comparison Operations</a></h2>
<p>Comparisons work as expected.  Equality is &quot;deep&quot; in the sense of doing
comparisons of the contents of data structures.</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: 'x &lt; z'}
  - {$eval: 'x &lt;= z'}
  - {$eval: 'x &gt; z'}
  - {$eval: 'x &gt;= z'}
  - {$eval: 'deep == [1, [3, {a: 5}]]'}
  - {$eval: 'deep != [1, [3, {a: 5}]]'}
context: {x: -10, z: 10, deep: [1, [3, {a: 5}]]}
result: [true, true, false, false, true, false]
</code></pre>
<h2 id="boolean-operations"><a class="header" href="#boolean-operations">Boolean Operations</a></h2>
<p>Boolean operations use C- and Javascript-style symbols <code>||</code>, <code>&amp;&amp;</code>, and <code>!</code>:</p>
<pre><code class="language-yaml json-e">template: {$eval: '!(false || false) &amp;&amp; true'}
context: {}
result: true
</code></pre>
<p>Json-e supports short-circuit evaluation, so if in <code>||</code> left operand is true 
returning value will be true no matter what right operand is:</p>
<pre><code class="language-yaml json-e">template: {$eval: &quot;true || b&quot;}
context: {}
result: true
</code></pre>
<p>And if in <code>&amp;&amp;</code> left operand is false returning value will be false no matter 
what right operand is:</p>
<pre><code class="language-yaml json-e">template: {$eval: &quot;false &amp;&amp; b&quot;}
context: {}
result: false
</code></pre>
<h2 id="object-property-access"><a class="header" href="#object-property-access">Object Property Access</a></h2>
<p>Like Javascript, object properties can be accessed either with array-index
syntax or with dot syntax. Unlike Javascript, <code>obj.prop</code> is an error if <code>obj</code>
does not have <code>prop</code>, while <code>obj['prop']</code> will evaluate to <code>null</code>.</p>
<pre><code class="language-yaml json-e">template: {$eval: 'v.a + v[&quot;b&quot;]'}
context: {v: {a: 'apple', b: 'banana', c: 'carrot'}}
result: 'applebanana'
</code></pre>
<p>Note that the object can be a literal expression:</p>
<pre><code class="language-yaml json-e">template: {$eval: '{ENOMEM:&quot;Out of memory&quot;, ENOCPU:&quot;Out of CPUs&quot;}[msgid]'}
context: {msgid: ENOMEM}
result: 'Out of memory'
</code></pre>
<p>When using the dot-syntax, e.g. <code>.prop</code>, identifiers may only contain letters,
underscores, and numbers, but may not start with a number (just like for context
references). While the context object may only have keys that meet these
requirements, nested objects may have keys in any format. Keys that are not in
the identifier format must be accessed using the bracket-name syntax, e.g.
<code>['my-prop']</code>.</p>
<h2 id="indexing-and-slicing"><a class="header" href="#indexing-and-slicing">Indexing and Slicing</a></h2>
<p>Strings and arrays can be indexed and sliced using a Python-like indexing
scheme.  Negative indexes are counted from the end of the value.  Slices are
treated as &quot;half-open&quot;, meaning that the result contains the first index and
does not contain the second index.  A &quot;backward&quot; slice with the start index
greater than the end index is treated as empty.</p>
<p>Strings are treated as a sequence of Unicode codepoints.</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: '[array[1], string[1]]'}
  - {$eval: '[array[1:4], string[1:4]]'}
  - {$eval: '[array[2:], string[2:]]'}
  - {$eval: '[array[:2], string[:2]]'}
  - {$eval: '[array[4:2], string[4:2]]'}
  - {$eval: '[array[-2], string[-2]]'}
  - {$eval: '[array[-2:], string[-2:]]'}
  - {$eval: '[array[:-3], string[:-3]]'}
context: {array: ['a', 'b', '☪', 'd', 'e'], string: 'ab☪de'}
result:
  - ['b', 'b']
  - [['b', '☪', 'd'], 'b☪d']
  - [['☪', 'd', 'e'], '☪de']
  - [['a', 'b'], 'ab']
  - [[], '']
  - ['d', 'd']
  - [['d', 'e'], 'de']
  - [['a', 'b'], 'ab']
</code></pre>
<h2 id="containment-operation"><a class="header" href="#containment-operation">Containment Operation</a></h2>
<p>The <code>in</code> keyword can be used to check for containment: a property in an object,
an element in an array, or a substring in a string.</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: '&quot;foo&quot; in {foo: 1, bar: 2}'}
  - {$eval: '&quot;foo&quot; in [&quot;foo&quot;, &quot;bar&quot;]'}
  - {$eval: '&quot;foo&quot; in &quot;foobar&quot;'}
context: {}
result: [true, true, true]
</code></pre>
<h2 id="function-invocation"><a class="header" href="#function-invocation">Function Invocation</a></h2>
<p>Function calls are made with the usual <code>fn(arg1, arg2)</code> syntax. Functions are
not JSON data, so they cannot be created in JSON-e, but they can be provided as
built-ins or supplied in the context and called from JSON-e.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-functions-and-variables"><a class="header" href="#built-in-functions-and-variables">Built-In Functions and Variables</a></h1>
<p>The expression language provides a laundry-list of built-in functions/variables. Library
users can easily add additional functions/variables, or override the built-ins, as part
of the context.</p>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>The built-in context value <code>now</code> is set to the current time at the start of
evaluation of the template, and used as the default &quot;from&quot; value for <code>$fromNow</code>
and the built-in <code>fromNow()</code>.</p>
<pre><code class="language-yaml json-e">template:
  - {$eval: 'now'}
  - {$eval: 'fromNow(&quot;1 minute&quot;)'}
  - {$eval: 'fromNow(&quot;1 minute&quot;, &quot;2017-01-19T16:27:20.974Z&quot;)'}
context: {}
result:
  - '2017-01-19T16:27:20.974Z'
  - '2017-01-19T16:28:20.974Z'
  - '2017-01-19T16:28:20.974Z'
</code></pre>
<h2 id="math"><a class="header" href="#math">Math</a></h2>
<pre><code class="language-yaml json-e">template:
  # the smallest of the arguments
  - {$eval: 'min(1, 3, 5)'}
  # the largest of the arguments
  - {$eval: 'max(2, 4, 6)'}
  # mathematical functions
  - {$eval: 'sqrt(16)'}
  - {$eval: 'ceil(0.3)'}
  - {$eval: 'floor(0.3)'}
  - {$eval: 'abs(-0.3)'}
context: {}
result:
  - 1
  - 6
  - 4
  - 1
  - 0
  - 0.3
</code></pre>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<pre><code class="language-yaml json-e">template:
  # convert string case
  - {$eval: 'lowercase(&quot;Fools!&quot;)'}
  - {$eval: 'uppercase(&quot;Fools!&quot;)'}
  # convert string, number, or boolean to string
  # (arrays and objects cannot be converted to string)
  - {$eval: 'str(130)'}
  # convert a string to a number (string is required)
  - {$eval: 'number(&quot;310&quot;)'}
  # strip whitespace from left, right, or both ends of a string
  - {$eval: 'lstrip(&quot;  room  &quot;)'}
  - {$eval: 'rstrip(&quot;  room  &quot;)'}
  - {$eval: 'strip(&quot;  room  &quot;)'}
  - {$eval: 'split(&quot;left:right&quot;, &quot;:&quot;)'}
context: {}
result:
  - &quot;fools!&quot;
  - &quot;FOOLS!&quot;
  - &quot;130&quot;
  - 310
  - &quot;room  &quot;
  - &quot;  room&quot;
  - room
  - [left, right]
</code></pre>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<pre><code class="language-yaml json-e">template:
  - {$eval: 'join([&quot;carpe&quot;, &quot;diem&quot;], &quot; &quot;)'}
  - {$eval: 'join([1, 3], 2)'}
context: {}
result:
  - carpe diem
  - '123'
</code></pre>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>The <code>defined(varname)</code> built-in determines if the named variable is defined in the current context.
The current context includes any variables defined or redefined by <code>$let</code> or similar operators.
Note that the name must be given as a string.</p>
<pre><code class="language-yaml json-e">template: {$if: 'defined(&quot;x&quot;)', then: {$eval: 'x'}, else: 20}
context: {y: 10}
result: 20
</code></pre>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p>The <code>typeof()</code> built-in returns the type of an object. Its behavior around
<code>null</code> is reminiscent of JavaScript.</p>
<pre><code class="language-yaml json-e">template:
 - &quot;${typeof('abc')}&quot;
 - &quot;${typeof(42)}&quot;
 - &quot;${typeof(42.0)}&quot;
 - &quot;${typeof(true)}&quot;
 - &quot;${typeof([])}&quot;
 - &quot;${typeof({})}&quot;
 - &quot;${typeof(typeof)}&quot;
 - {$eval: &quot;typeof(null)&quot;}
 - &quot;${typeof(null)}&quot;
context: {}
result:
 - string
 - number
 - number
 - boolean
 - array
 - object
 - function
 - 'null'
 - 'null'    # .. which interpolates to an empty string
</code></pre>
<h2 id="length"><a class="header" href="#length">Length</a></h2>
<p>The <code>len()</code> built-in returns the length of a string or array.</p>
<pre><code class="language-yaml json-e">template: {$eval: 'len([1, 2, 3])'}
context: {}
result: 3
</code></pre>
<h2 id="range"><a class="header" href="#range">Range</a></h2>
<p>The <code>range()</code> built-in generates an array based on the following inputs:</p>
<ul>
<li><code>start</code> - An integer specifying the lower bound of the range (inclusive).
This can be negative, in which case the generated array of integers will
start with this negative value (inclusive).</li>
<li><code>end</code> - An integer specifying the upper bound of the range (exclusive). This
can be negative, in which case the generated array of integers will end with
this negative value (exclusive).</li>
<li><code>step</code> - Optional. An integer specifying a step to apply to each value within
the range. If not specified, defaults to <code>1</code>. Can be negative, but cannot be
zero.</li>
</ul>
<p>The contents of a range r are determined by the following formula:</p>
<pre><code class="language-yaml json-e">IF step &gt; 0 THEN

  i = start
  WHILE i &lt; end:
    r(i) = i
    i = i + step
  END WHILE

ELSE if step &lt; 0 THEN

  i = start
  WHILE i &gt; end:
    r(i) = i
    i = i + step
  END WHILE

END IF
</code></pre>
<p>Notably, the resulting range will be empty if <code>start &gt;= end</code> and <code>step</code> is
positive or if <code>start &lt;= end</code> and <code>step</code> is negative.</p>
<pre><code class="language-yaml json-e">template:
  $map: {$eval: 'range(1, 5)'}
  each(x): {$eval: 'x'}
context:  {}
result:   [1, 2, 3, 4]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="playground"><a class="header" href="#playground">Playground</a></h1>
<p>This page executes JSON-e live in your browser.</p>
<pre><code class="language-yaml jsone-playground">template:
  message:
    $eval: payload.message_body
context:
  payload:
    message_body: &quot;Hello, world!&quot;
result:
  message: Hello, world!
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="docs/jsone.js"></script>
        <script type="text/javascript" src="js/dist/index.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
